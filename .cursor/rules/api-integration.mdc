---
globs: "Stalk_FE/src/services/**/*.ts,Stalk_FE/src/hooks/**/*.ts"
description: "API í†µì‹  ë° ë°±ì—”ë“œ ì—°ë™ ê·œì¹™"
---

# ğŸ”Œ API í†µì‹  ë° ë°±ì—”ë“œ ì—°ë™ ê·œì¹™

## ğŸš« ë°±ì—”ë“œ API ìˆ˜ì • ê¸ˆì§€ ì‚¬í•­

### ì ˆëŒ€ ë³€ê²½í•˜ì§€ ë§ ê²ƒ
- **API ì—”ë“œí¬ì¸íŠ¸ URL êµ¬ì¡° ë³€ê²½ ìš”êµ¬ ê¸ˆì§€**
- **ìš”ì²­/ì‘ë‹µ ë°ì´í„° í˜•ì‹ ë³€ê²½ ìš”êµ¬ ê¸ˆì§€**
- **HTTP ë©”ì„œë“œ ë³€ê²½ ìš”êµ¬ ê¸ˆì§€**
- **ì¸ì¦/ì¸ê°€ ë¡œì§ ë³€ê²½ ìš”êµ¬ ê¸ˆì§€**

### ê¸°ì¡´ API ê³„ì•½ ì¤€ìˆ˜
```typescript
// âœ… ê¸°ì¡´ ë°±ì—”ë“œ API í˜•ì‹ì— ë§ì¶° ê°œë°œ
interface BaseResponse<T> {
  success: boolean;
  message: string;
  data: T;
}

interface ErrorResponse {
  success: false;
  message: string;
  errorCode?: string;
}
```

## ğŸ”§ API ì„œë¹„ìŠ¤ ê³„ì¸µ êµ¬ì¡°

### ì„œë¹„ìŠ¤ íŒŒì¼ êµ¬ì¡°
```
src/services/
â”œâ”€â”€ index.ts              # ëª¨ë“  ì„œë¹„ìŠ¤ export
â”œâ”€â”€ authService.ts        # ì¸ì¦ ê´€ë ¨ API
â”œâ”€â”€ userService.ts        # ì‚¬ìš©ì ê´€ë ¨ API
â”œâ”€â”€ consultationService.ts # ìƒë‹´ ê´€ë ¨ API
â”œâ”€â”€ communityService.ts   # ì»¤ë®¤ë‹ˆí‹° ê´€ë ¨ API
â”œâ”€â”€ stockService.ts       # ì£¼ì‹ ê´€ë ¨ API
â””â”€â”€ apiClient.ts          # ê³µí†µ API í´ë¼ì´ì–¸íŠ¸
```

### API í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
```typescript
// src/services/apiClient.ts
import axios, { AxiosInstance, AxiosResponse } from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8081/api';

export const apiClient: AxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// ìš”ì²­ ì¸í„°ì…‰í„° - í† í° ìë™ ì¶”ê°€
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// ì‘ë‹µ ì¸í„°ì…‰í„° - ì—ëŸ¬ ì²˜ë¦¬
apiClient.interceptors.response.use(
  (response: AxiosResponse) => response,
  async (error) => {
    if (error.response?.status === 401) {
      // í† í° ë§Œë£Œ ì‹œ ë¦¬í”„ë ˆì‹œ ì‹œë„
      try {
        await refreshToken();
        return apiClient.request(error.config);
      } catch (refreshError) {
        // ë¦¬í”„ë ˆì‹œ ì‹¤íŒ¨ ì‹œ ë¡œê·¸ì•„ì›ƒ
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        window.location.href = '/login';
      }
    }
    return Promise.reject(error);
  }
);
```

## ğŸ“ API ì„œë¹„ìŠ¤ ì‘ì„± ê·œì¹™

### ì„œë¹„ìŠ¤ í´ë˜ìŠ¤ êµ¬ì¡°
```typescript
// src/services/userService.ts
import { apiClient } from './apiClient';
import type { BaseResponse } from '@/types';

interface User {
  id: string;
  email: string;
  name: string;
  profileImage?: string;
}

interface UpdateUserRequest {
  name?: string;
  profileImage?: File;
}

class UserService {
  // GET ìš”ì²­
  async getProfile(): Promise<User> {
    const response = await apiClient.get<BaseResponse<User>>('/users/profile');
    return response.data.data;
  }

  // POST ìš”ì²­ (FormData)
  async updateProfile(data: UpdateUserRequest): Promise<User> {
    const formData = new FormData();
    
    if (data.name) {
      formData.append('name', data.name);
    }
    if (data.profileImage) {
      formData.append('profileImage', data.profileImage);
    }

    const response = await apiClient.post<BaseResponse<User>>(
      '/users/profile',
      formData,
      {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      }
    );
    
    return response.data.data;
  }

  // DELETE ìš”ì²­
  async deleteAccount(): Promise<void> {
    await apiClient.delete('/users/account');
  }
}

export const userService = new UserService();
```

### API Hook íŒ¨í„´
```typescript
// src/hooks/useUserProfile.ts
import { useState, useEffect } from 'react';
import { userService } from '@/services';
import type { User } from '@/types';

interface UseUserProfileResult {
  user: User | null;
  loading: boolean;
  error: string | null;
  updateProfile: (data: UpdateUserRequest) => Promise<void>;
  refetch: () => void;
}

export const useUserProfile = (): UseUserProfileResult => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchProfile = async () => {
    try {
      setLoading(true);
      setError(null);
      const userData = await userService.getProfile();
      setUser(userData);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'í”„ë¡œí•„ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    } finally {
      setLoading(false);
    }
  };

  const updateProfile = async (data: UpdateUserRequest) => {
    try {
      const updatedUser = await userService.updateProfile(data);
      setUser(updatedUser);
    } catch (err) {
      throw new Error(err instanceof Error ? err.message : 'í”„ë¡œí•„ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    }
  };

  useEffect(() => {
    fetchProfile();
  }, []);

  return {
    user,
    loading,
    error,
    updateProfile,
    refetch: fetchProfile,
  };
};
```

## ğŸ” ì¸ì¦ ì²˜ë¦¬ ê·œì¹™

### í† í° ê´€ë¦¬
```typescript
// src/services/authService.ts
interface LoginRequest {
  email: string;
  password: string;
}

interface AuthResponse {
  accessToken: string;
  refreshToken: string;
  user: User;
}

class AuthService {
  async login(credentials: LoginRequest): Promise<AuthResponse> {
    const response = await apiClient.post<BaseResponse<AuthResponse>>(
      '/auth/login',
      credentials
    );
    
    const { accessToken, refreshToken, user } = response.data.data;
    
    // í† í° ì €ì¥
    localStorage.setItem('accessToken', accessToken);
    localStorage.setItem('refreshToken', refreshToken);
    
    return response.data.data;
  }

  async refreshToken(): Promise<string> {
    const refreshToken = localStorage.getItem('refreshToken');
    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await apiClient.post<BaseResponse<{ accessToken: string }>>(
      '/auth/refresh',
      { refreshToken }
    );

    const { accessToken } = response.data.data;
    localStorage.setItem('accessToken', accessToken);
    
    return accessToken;
  }

  async logout(): Promise<void> {
    await apiClient.post('/auth/logout');
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
  }
}

export const authService = new AuthService();
```

## ğŸ¯ ì—ëŸ¬ ì²˜ë¦¬ ê·œì¹™

### ì—ëŸ¬ íƒ€ì… ì •ì˜
```typescript
// src/types/error.ts
export interface ApiError {
  message: string;
  code?: string;
  status?: number;
}

export class ApiErrorHandler {
  static handle(error: unknown): ApiError {
    if (axios.isAxiosError(error)) {
      const status = error.response?.status;
      const message = error.response?.data?.message || error.message;
      const code = error.response?.data?.errorCode;

      return {
        message: this.getErrorMessage(status, message),
        code,
        status,
      };
    }

    return {
      message: 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
    };
  }

  private static getErrorMessage(status?: number, serverMessage?: string): string {
    if (serverMessage) return serverMessage;

    switch (status) {
      case 400:
        return 'ì˜ëª»ëœ ìš”ì²­ì…ë‹ˆë‹¤.';
      case 401:
        return 'ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.';
      case 403:
        return 'ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.';
      case 404:
        return 'ìš”ì²­í•œ ìì›ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
      case 500:
        return 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
      default:
        return 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
    }
  }
}
```

### ì»´í¬ë„ŒíŠ¸ì—ì„œ ì—ëŸ¬ ì²˜ë¦¬
```typescript
// ì»´í¬ë„ŒíŠ¸ì—ì„œ ì—ëŸ¬ ì²˜ë¦¬ ì˜ˆì‹œ
const UserProfile: React.FC = () => {
  const { user, loading, error, updateProfile } = useUserProfile();
  const [updateError, setUpdateError] = useState<string | null>(null);

  const handleUpdateProfile = async (data: UpdateUserRequest) => {
    try {
      setUpdateError(null);
      await updateProfile(data);
      // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
    } catch (err) {
      const apiError = ApiErrorHandler.handle(err);
      setUpdateError(apiError.message);
    }
  };

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;

  return (
    <div>
      {/* í”„ë¡œí•„ UI */}
      {updateError && <ErrorAlert message={updateError} />}
    </div>
  );
};
```

## ğŸ“Š ë°ì´í„° í˜ì¹­ íŒ¨í„´

### í˜ì´ì§€ë„¤ì´ì…˜
```typescript
interface PaginationParams {
  page: number;
  size: number;
}

interface PaginatedResponse<T> {
  content: T[];
  totalElements: number;
  totalPages: number;
  first: boolean;
  last: boolean;
}

const usePaginatedData = <T>(
  fetchFn: (params: PaginationParams) => Promise<PaginatedResponse<T>>,
  pageSize = 10
) => {
  const [data, setData] = useState<T[]>([]);
  const [page, setPage] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [loading, setLoading] = useState(false);

  const fetchData = useCallback(async (pageNumber = 0) => {
    setLoading(true);
    try {
      const response = await fetchFn({ page: pageNumber, size: pageSize });
      setData(response.content);
      setTotalPages(response.totalPages);
      setPage(pageNumber);
    } catch (error) {
      console.error('Data fetching failed:', error);
    } finally {
      setLoading(false);
    }
  }, [fetchFn, pageSize]);

  useEffect(() => {
    fetchData(0);
  }, [fetchData]);

  return {
    data,
    page,
    totalPages,
    loading,
    nextPage: () => fetchData(page + 1),
    previousPage: () => fetchData(page - 1),
    goToPage: fetchData,
  };
};
```

## ğŸ”„ ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬

### WebSocket ì—°ê²° (ìƒë‹´ ê¸°ëŠ¥)
```typescript
// OpenVidu ì—°ê²°ì€ ê¸°ì¡´ consultationService ì‚¬ìš©
import { consultationService } from '@/services';

const useConsultation = (sessionId: string) => {
  const [session, setSession] = useState<Session | null>(null);
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    const initSession = async () => {
      try {
        const sessionData = await consultationService.joinSession(sessionId);
        setSession(sessionData);
        setConnected(true);
      } catch (error) {
        console.error('Session connection failed:', error);
      }
    };

    initSession();

    return () => {
      if (session) {
        session.disconnect();
      }
    };
  }, [sessionId]);

  return { session, connected };
};
```

## ğŸ“ ìƒˆë¡œìš´ API ìš”ì²­ ì‹œ ì ˆì°¨

1. **ë°±ì—”ë“œ ê°œë°œìì™€ ìƒì˜**
   - ìƒˆë¡œìš´ ì—”ë“œí¬ì¸íŠ¸ í•„ìš”ì„± ì„¤ëª…
   - ìš”ì²­/ì‘ë‹µ í˜•ì‹ ë…¼ì˜
   - API ëª…ì„¸ì„œ ì—…ë°ì´íŠ¸ ìš”ì²­

2. **ê¸°ì¡´ íŒ¨í„´ í™•ì¸**
   - ë¹„ìŠ·í•œ ê¸°ëŠ¥ì˜ ê¸°ì¡´ API ì°¾ê¸°
   - ì¼ê´€ëœ í˜•ì‹ìœ¼ë¡œ ìš”ì²­

3. **í”„ë¡ íŠ¸ì—”ë“œ êµ¬í˜„**
   - ì„œë¹„ìŠ¤ ë ˆì´ì–´ì— ë©”ì„œë“œ ì¶”ê°€
   - ì»¤ìŠ¤í…€ í›… ìƒì„±
   - ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©

4. **í…ŒìŠ¤íŠ¸ ë° ê²€ì¦**
   - API ì‘ë‹µ í™•ì¸
   - ì—ëŸ¬ ì¼€ì´ìŠ¤ ì²˜ë¦¬
   - íƒ€ì… ì•ˆì „ì„± ê²€ì¦